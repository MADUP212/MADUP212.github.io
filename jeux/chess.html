<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu d'échecs avec IA</title>
  <style>
    body { 
      background: #fff; 
      color: #000; 
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
    }
    #container {
      display: flex;
      gap: 30px;
      align-items: flex-start;
    }
    #game-section {
      text-align: center;
    }
    #chessboard {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 0;
      border: 2px solid #111;
      margin: 20px auto;
    }
    .case {
      width: 60px; 
      height: 60px;
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 2em;
      cursor: pointer;
      user-select: none;
    }
    .white { background: #e3e3e3; }
    .black-square { background: #333; color: #fff; }
    .selected { border: 3px solid #009688; box-sizing: border-box; }
    .highlight { background: #ffeb3b !important; }
    #sidebar {
      border: 2px solid #111;
      padding: 20px;
      min-width: 200px;
      background: #f5f5f5;
    }
    #sidebar h3 {
      margin-top: 0;
      border-bottom: 2px solid #111;
      padding-bottom: 10px;
    }
    .info-line {
      margin: 10px 0;
      font-weight: bold;
    }
    #status {
      margin-top: 10px;
      font-size: 0.9em;
    }
    button {
      margin-top: 15px;
      padding: 10px 20px;
      background: #111;
      color: #fff;
      border: none;
      cursor: pointer;
      font-size: 1em;
    }
    button:hover {
      background: #333;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="game-section">
      <h2>Jeu d'échecs</h2>
      <div id="chessboard"></div>
      <p id="info">Sélectionnez une pièce blanche</p>
      <button onclick="resetGame()">Nouvelle partie</button>
    </div>
    <div id="sidebar">
      <h3>Statistiques IA</h3>
      <div class="info-line">ELO: <span id="elo">1500</span></div>
      <div class="info-line">Niveau: <span id="level">Normal</span></div>
      <div id="status">
        <p>Parties jouées: <span id="games">0</span></p>
        <p>Victoires joueur: <span id="wins">0</span></p>
        <p>Défaites joueur: <span id="losses">0</span></p>
      </div>
    </div>
  </div>

  <script>
    // Pièces Unicode
    const pieces = {
      r: '♜', n: '♞', b: '♝', q: '♛', k: '♚', p: '♟',
      R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔', P: '♙'
    };

    // Valeurs des pièces pour l'évaluation
    const pieceValues = {
      p: 10, n: 30, b: 30, r: 50, q: 90, k: 900,
      P: -10, N: -30, B: -30, R: -50, Q: -90, K: -900
    };

    // Position initiale
    let initialBoard = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];

    let board = JSON.parse(JSON.stringify(initialBoard));
    let selected = null;
    let turn = 'white';
    let gameOver = false;

    // Suivi des mouvements pour le roque
    let whiteKingMoved = false;
    let whiteRookKingsideMoved = false;
    let whiteRookQueensideMoved = false;
    let blackKingMoved = false;
    let blackRookKingsideMoved = false;
    let blackRookQueensideMoved = false;

    // Système ELO
    let aiElo = 1500;
    let playerElo = 1500;
    let gamesPlayed = 0;
    let playerWins = 0;
    let playerLosses = 0;

    function drawBoard() {
      const chessboard = document.getElementById('chessboard');
      chessboard.innerHTML = '';
      for (let i=0; i<8; i++) {
        for (let j=0; j<8; j++) {
          const cell = document.createElement('div');
          cell.className = 'case ' + ((i+j)%2 ? 'black-square' : 'white');
          cell.id = `cell-${i}-${j}`;
          cell.textContent = pieces[board[i][j]] || '';
          if (selected && selected[0]===i && selected[1]===j) {
            cell.classList.add('selected');
          }
          cell.onclick = ()=>handleClick(i,j);
          chessboard.appendChild(cell);
        }
      }
    }

    function isSquareAttacked(row, col, byBlack) {
      // Vérifie si une case est attaquée par un joueur
      for (let i=0; i<8; i++) {
        for (let j=0; j<8; j++) {
          const piece = board[i][j];
          if (!piece) continue;
          if (byBlack && piece !== piece.toLowerCase()) continue;
          if (!byBlack && piece !== piece.toUpperCase()) continue;
          
          if (canPieceAttack(i, j, row, col)) return true;
        }
      }
      return false;
    }

    function canPieceAttack(fromI, fromJ, toI, toJ) {
      const piece = board[fromI][fromJ];
      if (!piece) return false;
      
      const pieceLower = piece.toLowerCase();
      const di = toI - fromI;
      const dj = toJ - fromJ;
      
      if (pieceLower === 'p') {
        const direction = piece === 'P' ? -1 : 1;
        return (Math.abs(dj) === 1 && di === direction);
      }
      if (pieceLower === 'n') {
        return (Math.abs(di)===2 && Math.abs(dj)===1) || (Math.abs(di)===1 && Math.abs(dj)===2);
      }
      if (pieceLower === 'k') {
        return Math.abs(di) <= 1 && Math.abs(dj) <= 1;
      }
      if (pieceLower === 'r') {
        return (di === 0 || dj === 0) && isPathClear(fromI, fromJ, toI, toJ);
      }
      if (pieceLower === 'b') {
        return Math.abs(di) === Math.abs(dj) && isPathClear(fromI, fromJ, toI, toJ);
      }
      if (pieceLower === 'q') {
        return ((di === 0 || dj === 0) || Math.abs(di) === Math.abs(dj)) && isPathClear(fromI, fromJ, toI, toJ);
      }
      return false;
    }

    function canCastle(kingSide, isWhite) {
      const row = isWhite ? 7 : 0;
      const kingCol = 4;
      
      // Vérifier si le roi et la tour ont déjà bougé
      if (isWhite) {
        if (whiteKingMoved) return false;
        if (kingSide && whiteRookKingsideMoved) return false;
        if (!kingSide && whiteRookQueensideMoved) return false;
      } else {
        if (blackKingMoved) return false;
        if (kingSide && blackRookKingsideMoved) return false;
        if (!kingSide && blackRookQueensideMoved) return false;
      }
      
      // Vérifier que les pièces sont aux bonnes positions
      if (board[row][kingCol] !== (isWhite ? 'K' : 'k')) return false;
      const rookCol = kingSide ? 7 : 0;
      if (board[row][rookCol] !== (isWhite ? 'R' : 'r')) return false;
      
      // Vérifier que les cases entre le roi et la tour sont vides
      const start = Math.min(kingCol, rookCol) + 1;
      const end = Math.max(kingCol, rookCol);
      for (let col = start; col < end; col++) {
        if (board[row][col]) return false;
      }
      
      // Vérifier que le roi n'est pas en échec et ne traverse pas une case attaquée
      const direction = kingSide ? 1 : -1;
      for (let i = 0; i <= 2; i++) {
        const col = kingCol + (i * direction);
        if (col < 0 || col > 7) continue;
        if (isSquareAttacked(row, col, !isWhite)) return false;
      }
      
      return true;
    }

    function performCastle(kingSide, isWhite) {
      const row = isWhite ? 7 : 0;
      const king = isWhite ? 'K' : 'k';
      const rook = isWhite ? 'R' : 'r';
      
      if (kingSide) {
        // Petit roque
        board[row][6] = king;
        board[row][5] = rook;
        board[row][4] = '';
        board[row][7] = '';
      } else {
        // Grand roque
        board[row][2] = king;
        board[row][3] = rook;
        board[row][4] = '';
        board[row][0] = '';
      }
      
      // Marquer que le roi et la tour ont bougé
      if (isWhite) {
        whiteKingMoved = true;
        if (kingSide) whiteRookKingsideMoved = true;
        else whiteRookQueensideMoved = true;
      } else {
        blackKingMoved = true;
        if (kingSide) blackRookKingsideMoved = true;
        else blackRookQueensideMoved = true;
      }
    }

    function isValidMove(fromI, fromJ, toI, toJ) {
      if (toI < 0 || toI > 7 || toJ < 0 || toJ > 7) return false;
      const piece = board[fromI][fromJ];
      const target = board[toI][toJ];
      
      // Ne peut pas capturer ses propres pièces
      if (piece && target) {
        if ((piece === piece.toUpperCase() && target === target.toUpperCase()) ||
            (piece === piece.toLowerCase() && target === target.toLowerCase())) {
          return false;
        }
      }
      
      // Vérifier le roque pour le roi
      const pieceLower = piece.toLowerCase();
      if (pieceLower === 'k') {
        const isWhite = piece === 'K';
        const expectedRow = isWhite ? 7 : 0;
        
        // Roque côté roi (petit roque)
        if (fromI === expectedRow && fromJ === 4 && toI === expectedRow && toJ === 6) {
          return canCastle(true, isWhite);
        }
        // Roque côté dame (grand roque)
        if (fromI === expectedRow && fromJ === 4 && toI === expectedRow && toJ === 2) {
          return canCastle(false, isWhite);
        }
      }
      
      // Mouvements normaux
      const di = toI - fromI;
      const dj = toJ - fromJ;
      
      if (pieceLower === 'p') {
        const direction = piece === 'P' ? -1 : 1;
        if (dj === 0 && di === direction && !target) return true;
        if (dj === 0 && di === 2*direction && fromI === (piece === 'P' ? 6 : 1) && !target && !board[fromI+direction][fromJ]) return true;
        if (Math.abs(dj) === 1 && di === direction && target) return true;
      }
      if (pieceLower === 'n') {
        if ((Math.abs(di)===2 && Math.abs(dj)===1) || (Math.abs(di)===1 && Math.abs(dj)===2)) return true;
      }
      if (pieceLower === 'k') {
        if (Math.abs(di) <= 1 && Math.abs(dj) <= 1) return true;
      }
      if (pieceLower === 'r') {
        if ((di === 0 || dj === 0) && isPathClear(fromI, fromJ, toI, toJ)) return true;
      }
      if (pieceLower === 'b') {
        if (Math.abs(di) === Math.abs(dj) && isPathClear(fromI, fromJ, toI, toJ)) return true;
      }
      if (pieceLower === 'q') {
        if (((di === 0 || dj === 0) || Math.abs(di) === Math.abs(dj)) && isPathClear(fromI, fromJ, toI, toJ)) return true;
      }
      
      return false;
    }

    function isPathClear(fromI, fromJ, toI, toJ) {
      const di = Math.sign(toI - fromI);
      const dj = Math.sign(toJ - fromJ);
      let i = fromI + di;
      let j = fromJ + dj;
      
      while (i !== toI || j !== toJ) {
        if (board[i][j]) return false;
        i += di;
        j += dj;
      }
      return true;
    }

    function getAllMoves(forBlack) {
      const moves = [];
      for (let i=0; i<8; i++) {
        for (let j=0; j<8; j++) {
          const piece = board[i][j];
          if (!piece) continue;
          if (forBlack && piece !== piece.toLowerCase()) continue;
          if (!forBlack && piece !== piece.toUpperCase()) continue;
          
          for (let ti=0; ti<8; ti++) {
            for (let tj=0; tj<8; tj++) {
              if (isValidMove(i, j, ti, tj)) {
                moves.push({from: [i,j], to: [ti,tj]});
              }
            }
          }
        }
      }
      return moves;
    }

    function evaluateBoard() {
      let score = 0;
      for (let i=0; i<8; i++) {
        for (let j=0; j<8; j++) {
          if (board[i][j]) score += pieceValues[board[i][j]];
        }
      }
      return score;
    }

    function minimax(depth, isMaximizing, alpha, beta) {
      if (depth === 0) return evaluateBoard();
      
      const moves = getAllMoves(isMaximizing);
      if (moves.length === 0) return isMaximizing ? -10000 : 10000;
      
      if (isMaximizing) {
        let maxEval = -Infinity;
        for (let move of moves) {
          const [fi, fj] = move.from;
          const [ti, tj] = move.to;
          const temp = board[ti][tj];
          const tempPiece = board[fi][fj];
          
          // Sauvegarder l'état du roque
          const savedState = {
            whiteKingMoved, whiteRookKingsideMoved, whiteRookQueensideMoved,
            blackKingMoved, blackRookKingsideMoved, blackRookQueensideMoved
          };
          
          makeMove(fi, fj, ti, tj);
          const evaluation = minimax(depth - 1, false, alpha, beta);
          
          // Restaurer
          board[fi][fj] = tempPiece;
          board[ti][tj] = temp;
          Object.assign(this, savedState);
          
          maxEval = Math.max(maxEval, evaluation);
          alpha = Math.max(alpha, evaluation);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (let move of moves) {
          const [fi, fj] = move.from;
          const [ti, tj] = move.to;
          const temp = board[ti][tj];
          const tempPiece = board[fi][fj];
          
          const savedState = {
            whiteKingMoved, whiteRookKingsideMoved, whiteRookQueensideMoved,
            blackKingMoved, blackRookKingsideMoved, blackRookQueensideMoved
          };
          
          makeMove(fi, fj, ti, tj);
          const evaluation = minimax(depth - 1, true, alpha, beta);
          
          board[fi][fj] = tempPiece;
          board[ti][tj] = temp;
          Object.assign(this, savedState);
          
          minEval = Math.min(minEval, evaluation);
          beta = Math.min(beta, evaluation);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function makeMove(fromI, fromJ, toI, toJ) {
      const piece = board[fromI][fromJ];
      const pieceLower = piece.toLowerCase();
      const isWhite = piece === piece.toUpperCase();
      
      // Vérifier si c'est un roque
      if (pieceLower === 'k') {
        const expectedRow = isWhite ? 7 : 0;
        if (fromI === expectedRow && fromJ === 4) {
          if (toJ === 6) {
            performCastle(true, isWhite);
            return;
          } else if (toJ === 2) {
            performCastle(false, isWhite);
            return;
          }
        }
      }
      
      // Mouvement normal
      board[toI][toJ] = board[fromI][fromJ];
      board[fromI][fromJ] = '';
      
      // Marquer les pièces qui ont bougé
      if (pieceLower === 'k') {
        if (isWhite) whiteKingMoved = true;
        else blackKingMoved = true;
      }
      if (pieceLower === 'r') {
        if (isWhite) {
          if (fromI === 7 && fromJ === 7) whiteRookKingsideMoved = true;
          if (fromI === 7 && fromJ === 0) whiteRookQueensideMoved = true;
        } else {
          if (fromI === 0 && fromJ === 7) blackRookKingsideMoved = true;
          if (fromI === 0 && fromJ === 0) blackRookQueensideMoved = true;
        }
      }
    }

    function aiMove() {
      const depth = Math.min(3, Math.floor((aiElo - 1200) / 200) + 2);
      const moves = getAllMoves(true);
      
      if (moves.length === 0) {
        endGame('white');
        return;
      }
      
      let bestMove = null;
      let bestValue = -Infinity;
      
      for (let move of moves) {
        const [fi, fj] = move.from;
        const [ti, tj] = move.to;
        const temp = board[ti][tj];
        const tempPiece = board[fi][fj];
        
        const savedState = {
          whiteKingMoved, whiteRookKingsideMoved, whiteRookQueensideMoved,
          blackKingMoved, blackRookKingsideMoved, blackRookQueensideMoved
        };
        
        makeMove(fi, fj, ti, tj);
        const value = minimax(depth - 1, false, -Infinity, Infinity);
        
        board[fi][fj] = tempPiece;
        board[ti][tj] = temp;
        Object.assign(this, savedState);
        
        if (value > bestValue) {
          bestValue = value;
          bestMove = move;
        }
      }
      
      if (bestMove) {
        makeMove(bestMove.from[0], bestMove.from[1], bestMove.to[0], bestMove.to[1]);
        turn = 'white';
        
        if (getAllMoves(false).length === 0) {
          endGame('black');
        }
      }
      
      drawBoard();
      document.getElementById('info').textContent = 'À vous de jouer (Blancs)';
    }

    function handleClick(i, j) {
      if (gameOver || turn !== 'white') return;
      
      if (!selected) {
        if (board[i][j] && board[i][j] === board[i][j].toUpperCase()) {
          selected = [i, j];
          document.getElementById('info').textContent = `Sélectionné: ${pieces[board[i][j]]}`;
          drawBoard();
        }
      } else {
        if (isValidMove(selected[0], selected[1], i, j)) {
          makeMove(selected[0], selected[1], i, j);
          selected = null;
          
          if (getAllMoves(true).length === 0) {
            endGame('white');
            drawBoard();
            return;
          }
          
          turn = 'black';
          document.getElementById('info').textContent = 'IA réfléchit...';
          drawBoard();
          setTimeout(aiMove, 500);
        } else {
          selected = null;
          drawBoard();
          document.getElementById('info').textContent = 'Mouvement invalide';
        }
      }
    }

    function updateElo(winner) {
      const K = 32;
      const expectedPlayer = 1 / (1 + Math.pow(10, (aiElo - playerElo) / 400));
      const expectedAI = 1 / (1 + Math.pow(10, (playerElo - aiElo) / 400));
      
      if (winner === 'white') {
        playerElo = playerElo + K * (1 - expectedPlayer);
        aiElo = aiElo + K * (0 - expectedAI);
        playerWins++;
        aiElo += 50;
      } else {
        playerElo = playerElo + K * (0 - expectedPlayer);
        aiElo = aiElo + K * (1 - expectedAI);
        playerLosses++;
      }
      
      gamesPlayed++;
      updateStats();
    }

    function updateStats() {
      document.getElementById('elo').textContent = Math.round(aiElo);
      document.getElementById('games').textContent = gamesPlayed;
      document.getElementById('wins').textContent = playerWins;
      document.getElementById('losses').textContent = playerLosses;
      
      let level = 'Débutant';
      if (aiElo >= 2000) level = 'Expert';
      else if (aiElo >= 1700) level = 'Avancé';
      else if (aiElo >= 1400) level = 'Normal';
      document.getElementById('level').textContent = level;
    }

    function endGame(winner) {
      gameOver = true;
      const msg = winner === 'white' ? 'Vous avez gagné!' : 'L\'IA a gagné!';
      document.getElementById('info').textContent = msg;
      updateElo(winner);
    }

    function resetGame() {
      board = JSON.parse(JSON.stringify(initialBoard));
      selected = null;
      turn = 'white';
      gameOver = false;
      whiteKingMoved = false;
      whiteRookKingsideMoved = false;
      whiteRookQueensideMoved = false;
      blackKingMoved = false;
      blackRookKingsideMoved = false;
      blackRookQueensideMoved = false;
      drawBoard();
      document.getElementById('info').textContent = 'Nouvelle partie - À vous de jouer (Blancs)';
    }

    drawBoard();
    updateStats();
  </script>
</body>
</html>
